/// <reference types="node" />
import { EventEmitter } from "events";
declare enum DelimiterSearchState {
    START = 0,
    CR = 1,
    CR_LF = 2,
    CR_LF_DOT = 3,
    CR_LF_DOT_CR = 4
}
declare enum Delimiter {
    CRLF = 0,
    MLDB = 1
}
/**
 * A match may or may not have been made. In either case, a preceding chunk of data may be
 * available that did not match the needle. Data (if available) is in `chunk` between `start`
 * (inclusive) and `end` (exclusive).
 *
 * @param isMatch Whether a match had been made (after the chunk)
 * @param chunk Buffer of data
 * @param start Start position of data in chunk (inclusive)
 * @param end Start position of data in chunk (exclusive)
 *
 * @asMemberOf DotUnstuffingStreamSearch
 * @event
 */
export declare function info(isMatch: boolean, chunk: Buffer, start: number, end: number): void;
/**
 * Searches for needle in stream while also dot-unstuffing.
 */
export default class DotUnstuffingStreamSearch extends EventEmitter {
    _bufpos: number;
    _needle: Delimiter;
    _searchState: DelimiterSearchState;
    matches: number;
    maxMatches: number;
    /**
     *
     * @param needle Must me `Buffer.from("\r\n.\r\n")`
     */
    constructor(needle: Buffer);
    /**
     * Resets internal state
     */
    reset(): void;
    /**
     * Processes `chunk`.
     * @param chunk
     * @param pos
     *
     * @fires info
     *
     * @returns The last processed index in chunk + 1.
     */
    push(chunk: Buffer, pos?: number): number;
    /**
     * @private
     * @param data
     */
    _feed(data: Buffer): number;
}
export {};
